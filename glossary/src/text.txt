INTRODUCTION
It all started with a bean. In 1996, the Java programming language was still a young, exciting, up-and-coming platform. Many developers flocked to the language because they’d seen how to create rich and dynamic web applica-tions using applets. They soon learned that there was more to this strange new language than animated juggling cartoon characters. Unlike any language be-fore it, Java made it possible to write complex applications made up of dis-crete parts. They came for the applets, but they stayed for the components. In December of that year, Sun Microsystems published the JavaBeans 1.00-A specification. JavaBeans defined a software component model for Java. This specification defined a set of coding policies that enabled simple Java objects to be reusable and easily composed into more complex applications. Although JavaBeans were intended as a general-purpose means of defining reusable ap-plication components, they were primarily used as a model for building user interface widgets. They seemed too simple to be capable of any “real” work. Enterprise developers wanted more. Sophisticated applications often require services such as transaction support, security, and distributed computing—services not directly provided by the JavaBeans specification. So in March 1998, Sun published version 1.0 of the Enterprise JavaBeans (EJB) specifica-tion. This specification extended the notion of Java components to the server side, providing much-needed enterprise services, but failed to continue the simplicity of the original JavaBeans specification. Except in name, EJB bears little resemblance to the original JavaBeans specification. Despite the fact that many successful applications have been built based on EJB, EJB never achieved its intended purpose: to simplify enterprise application development. It’s true that EJB’s declarative programming model simplifies many infrastruc-tural aspects of development, such as transactions and security. But in a dif-ferent way, EJBs complicate development by mandating deployment de-scriptors and plumbing code (home and remote/local interfaces). Over time, many developers became disenchanted with EJB. As a result, its popularity has waned in recent years, leaving many developers looking for an easier way. Today, Java component development has returned to its roots. New program-ming techniques, including aspect-oriented programming (AOP) and dependen-cy injection (DI), are giving JavaBeans much of the power previously reserved for EJBs. These techniques furnish plain-old Java objects (POJOs) with a de-clarative programming model reminiscent of EJB, but without all of EJB’s complexity. No longer must you resort to writing an unwieldy EJB component when a simple Java Bean will suffice. In fairness, even EJBs have evolved to promote a POJO-based programming model. Employing ideas such as DI and AOP, the latest EJB specification is significantly simpler than its predecessors. But for many developers, this move is too little, too late. By the time the EJB 3 specification had entered the scene, other POJO-based development frame-works had already established themselves as de facto standards in the Java community.
 
1 SIMPLIFYING JAVA DEVELOPMENT 
Spring is an open source framework, originally created by Rod Johnson and described in his book Expert One-on-One: J2EE Design and Development. Spring was created to address the complexity of enterprise application devel-opment, and makes it possible to use plain-vanilla JavaBeans to achieve things that were previously only possible with EJBs. But Spring’s usefulness isn’t limited to server-side development. Any Java application can benefit from Spring in terms of simplicity, testability, and loose coupling.
Spring does many things. But at the root of almost everything Spring provides are a few foundational ideas, all focused on Spring’s fundamental mission: Spring simplifies Java development. That’s a bold statement! A lot of frameworks claim to simplify something or other. But Spring aims to simplify the broad subject of Java development. This begs for more explanation. How does Spring simplify Java development? To back up its attack on Java com-plexity, Spring employs four key strategies:
o	Lightweight and minimally invasive development with plain old Java objects (POJOs) 
o	Loose coupling through dependency injection and interface orien-tation
o	Declarative programming through aspects and common conven-tions 
o	Boilerplate reduction through aspects and templates

Almost everything Spring does can be traced back to one or more of these four strategies.
Also Spring avoids (as much as possible) littering your application code with its API. Spring almost never forces you to implement a Spring-specific interface or extend a Spring-specific class. Instead, the classes in a Spring-based application often have no indication that they’re being used by Spring. At worst, a class may be annotated with one of Spring’s annotations, but is otherwise a POJO.
2 SPRING’S MODULES
As you’ve seen, the Spring Framework is focused on simplifying enter-prise Java development through dependency injection, aspect-oriented pro-gramming, and boiler- plate reduction. Even if that were all that Spring did, it’d be worth using. But there’s more to Spring than meets the eye. Within the Spring Framework proper, you’ll find several ways that Spring can ease Java development. But beyond the Spring Framework itself is a greater ecosystem of projects that build upon the core framework, extending Spring into areas such as web services, OSGi, Flash, and even .NET.
Spring consist of different categories of functionality, as illustrated in as illustrated in figure 2.1. 
 
Figure 2.1 The Spring Framework is made up of well-defined modules
When taken as a whole, these modules give you everything you need to develop enterprise-ready applications. But you don’t have to base your appli-cation fully on the Spring Framework. You’re free to choose the modules that suit your application and look to other options when Spring doesn’t fit the bill. Spring even offers integration points with several other frameworks and librar-ies so that you won’t have to write them yourself.
Let’s take a look at each of Spring’s modules, one at a time, to see how each fits in the overall Spring picture.

2 Spring Inversion of control container
Central to the Spring Framework is its inversion of control (IoC) con-tainer, which provides a consistent means of configuring and managing Java objects using reflection. The container is responsible for managing object lifecycles of specific objects: creating these objects, calling their initialization methods, and configuring these objects by wiring them together.
Within this module you’ll find the Spring bean factory, which is the por-tion of Spring that provides dependency injection. Building upon the bean fac-tory, you’ll find several implementations of Spring’s application context, each of which provides a different way to configure Spring.
In addition to the bean factory and application context, this module also supplies many enterprise services such as email, JNDI access, EJB integration, and scheduling.
Objects created by the container are also called managed objects or beans. The container can be configured by loading XML files or detecting spe-cific Java annotations on configuration classes. These data sources contain the bean definitions that provide the information required to create the beans.
Objects can be obtained by means of either dependency lookup or de-pendency injection. Dependency lookup is a pattern where a caller asks the container object for an object with a specific name or of a specific type. De-pendency injection is a pattern where the container passes objects by name to other objects, via either constructors, properties, or factory methods.
In many cases one need not use the container when using other parts of the Spring Framework, although using it will likely make an application easier to configure and customize. The Spring container provides a consistent mecha-nism to configure applications and integrates with almost all Java environ-ments, from small-scale applications to large enterprise applications.
The container can be turned into a partially compliant EJB 3.0 container by means of the Pitchfork project. Some criticize the Spring Framework for not complying with standards. However, Spring Source doesn't see EJB 3 compli-ance as a major goal, and claims that the Spring Framework and the container allow for more powerful programming models. You do not create an object, but describe how they should be created, by defining it in the Spring configura-tion file. You do not call services and components, but tell which services and components must be called, by defining them in the Spring configuration files. This makes the code easy to maintain and easier to test through IoC.


Spring Security

Spring Security is a security framework that provides declarative securi-ty for your Spring-based applications. Spring Security provides a comprehen-sive security solution, handling authentication and authorization at both the web request level and at the method invocation level. Based on the Spring Framework, Spring Security takes full advantage of dependency injection (DI) and aspect-oriented techniques. Spring Security got its start as Acegi Security. Acegi was a powerful security framework, but it had one big turn-off: it re-quired a lot of XML configuration. Suffice it to say that it was common for a typical Acegi configuration to grow to several hundred lines of XML.
With version 2.0, Acegi Security became Spring Security. But the 2.0 re-lease brought more than just a superficial name change. Spring Security 2.0 in-troduced a new security-specific XML namespace for configuring security in Spring. The new namespace, along with annotations and reasonable defaults, slimmed typical security configuration from hundreds of lines to only a dozen or so lines of XML. Spring Security 3.0, the most recent release, added SpEL to the mix, simplifying security configuration even more. Spring Security tack-les security from two angles. To secure web requests and restrict access at the URL level, Spring Security uses servlet filters. Spring Security can also secure method invocations using Spring AOP—proxying objects and applying advice that ensures that the user has proper authority to invoke secured methods.

Spring Model-View-Controller

The Model-View-Controller (MVC) paradigm is a commonly accepted approach to building web applications such that the user interface is separate from the application logic. Java has no shortage of MVC frameworks, with Apache Struts, JSF, WebWork, and Tapestry among the most popular MVC choices.
Even though Spring integrates with several popular MVC frameworks, its web and remoting module comes with a capable MVC framework that promotes Spring’s loosely coupled techniques in the web layer of an applica-tion. This framework comes in two forms: a servlet-based framework for con-ventional web applications and aportlet-based application for developing against the Java portlet API.
The Spring Framework features its own MVC web application frame-work, which wasn't originally planned. The Spring developers decided to write their own Web framework as a reaction to what they perceived as the poor de-sign of the popular Jakarta Struts Web framework, as well as deficiencies in other available frameworks. In particular, they felt there was insufficient sepa-ration between the presentation and request handling layers, and between the request handling layer and the model.
Like Struts, Spring MVC is a request-based framework. The framework defines strategy interfaces for all of the responsibilities that must be handled by a modern request-based framework. The goal of each interface is to be simple and clear so that it's easy for Spring MVC users to write their own implemen-tations, if they so choose. MVC paves the way for cleaner front end code. All interfaces are tightly coupled to the Servlet API. This tight coupling to the Servlet API is seen by some as a failure on the part of the Spring developers to offer a high-level abstraction for Web-based applications. However, this cou-pling makes sure that the features of the Servlet API remain available to devel-opers while offering a high abstraction framework to ease working with said API.
The DispatcherServlet class is the front controller of the framework and is responsible for delegating control to the various interfaces during the execu-tion phases of a HTTP request.
•	The most important interfaces defined by Spring MVC, and their re-sponsibilities, are listed below:
•	Controller: comes between Model and View to manage incoming requests and redirect to proper response. It acts as a gate that directs the incom-ing information. It switches between going into model or view.
•	HandlerAdapter: execution of objects that handle incoming requests
•	HandlerInterceptor: interception of incoming requests comparable, but not equal to Servlet filters (use is optional and not controlled by Dis-patcherServlet).
•	HandlerMapping: selecting objects that handle incoming requests (han-dlers) based on any attribute or condition internal or external to those requests
•	LocaleResolver: resolving and optionally saving of the locale of an indi-vidual user
•	MultipartResolver: facilitate working with file uploads by wrapping in-coming requests
•	View: responsible for returning a response to the client. Some requests may go straight to view without going to the model part; others may go through all three.
•	ViewResolver: selecting a View based on a logical name for the view (use is not strictly required)

Each strategy interface above has an important responsibility in the overall framework. The abstractions offered by these interfaces are powerful, so to allow for a set of variations in their implementations, Spring MVC ships with implementations of all these interfaces and together offers a feature set on top of the Servlet API. However, developers and vendors are free to write oth-er implementations. Spring MVC uses the Java java.util.Map interface as a da-ta-oriented abstraction for the Model where keys are expected to be string val-ues.
The ease of testing the implementations of these interfaces seems one important advantage of the high level of abstraction offered by Spring MVC. DispatcherServlet is tightly coupled to the Spring inversion of control contain-er for configuring the web layers of applications. However, web applications can use other parts of the Spring Framework—including the container—and choose not to use Spring MVC.

Spring Aspect-oriented programming 

The Spring Framework has its own AOP framework that modularizes cross-cutting concerns in aspects. The motivation for creating a separate AOP framework comes from the belief that it would be possible to provide basic AOP features without too much complexity in either design, implementation, or configuration. The Spring AOP framework also takes full advantage of the Spring container.
The Spring AOP framework is proxy pattern-based, and is configured at run time. This removes the need for a compilation step or load-time weaving. On the other hand, interception only allows for public method-execution on ex-isting objects at a join point.
Compared to the AspectJ framework, Spring AOP is less powerful, but also less complicated. Spring 1.2 includes support to configure AspectJ as-pects in the container. Spring 2.0 added more integration with AspectJ; for ex-ample, the pointcut language is reused and can be mixed with Spring AOP-based aspects. Further, Spring 2.0 added a Spring Aspects library that uses AspectJ to offer common Spring features such as declarative transaction man-agement and dependency injection via AspectJ compile-time or load-time weaving. SpringSource also uses AspectJ AOP in other Spring projects such as Spring Roo and Spring Insight, with Spring Security also offering an As-pectJ-based aspect library.
Spring AOP has been designed to make it able to work with cross-cutting concerns inside the Spring Framework. Any object which is created and con-figured by the container can be enriched using Spring AOP.
The Spring Framework uses Spring AOP internally for transaction man-agement, security, remote access, and JMX.


Spring data access 

Working with JDBC often results in a lot of boilerplate code that gets a connection, creates a statement, processes a result set, and then closes the con-nection. Spring’s JDBC and data access objects (DAO) module abstracts away the boilerplate code so that you can keep your database code clean and simple, and prevents problems that result from a failure to close database resources. This module also builds a layer of meaningful exceptions on top of the error messages given by several database servers. 
For those who prefer using an object-relational mapping (ORM) tool over straight JDBC, Spring provides the ORM module. Spring’s ORM sup-port builds on the DAO support, providing a convenient way to build DAOs for several ORM solutions. Spring doesn’t attempt to implement its own ORM solution, but does provide hooks into several popular ORM frameworks, in-cluding Hibernate, Java Persistence API, Java Data Objects, and iBATIS SQL Maps. 
For all of these supported frameworks, Spring provides these features:
•	Resource management - automatically acquiring and releasing data-base resources
•	Exception handling - translating data access related exception to a Spring data access hierarchy
•	Transaction participation - transparent participation in ongoing trans-actions
•	Resource unwrapping - retrieving database objects from connection pool wrappers
•	Abstraction for BLOB(Binary large object) and CLOB(Character large object) handling
Spring’s transaction management supports each of these ORM frame-works as well as JDBC. Spring’s template-based JDBC abstraction can greatly simplify JDBC code. This module also includes a Spring abstraction over the Java Message Service (JMS) for asynchronous integration with other applica-tions through messaging. 
All these features become available when using template classes provided by Spring for each supported framework. Critics have said these template classes are intrusive and offer no advantage over using (for example) the Hi-bernate API directly. In response, the Spring developers have made it possible to use the Hibernate and JPA APIs directly. This however requires transparent transaction management, as application code no longer assumes the responsi-bility to obtain and close database resources, and does not support exception translation.
Together with Spring's transaction management, its data access frame-work offers a flexible abstraction for working with data access frameworks. The Spring Framework doesn't offer a common data access API; instead, the full power of the supported APIs is kept intact. The Spring Framework is the only framework available in Java that offers managed data access environ-ments outside of an application server or container.
Spring REST
A mistake that’s often made when approaching REST is to think of it as “web services with URLs”—to think of REST as another remote procedure call (RPC) mechanism, like SOAP, but invoked through plain HTTP URLs and without SOAP’s hefty XML namespaces.
On the contrary, REST has little to do with RPC. Whereas RPC is ser-vice-oriented and focused on actions and verbs, REST is resource-oriented, emphasizing the things and nouns that describe an application.
Also, although URLs play a key role in REST, they’re only a part of the story. To understand what REST is all about, it helps to break down the acro-nym into its constituent parts:
•	Representational—REST resources can be represented in virtually any form, including XML, JavaScript Object Notation (JSON), or even HTML—whatever form best suits the consumer of those resources.
•	State—When working with REST, we’re more concerned with the state of are source than with the actions we can take against resources.
•	Transfer—REST involves transferring resource data, in some represen-tational form, from one application to another.
Put more succinctly, REST is about transferring the state of resources—in whatever form is most appropriate—from a server to a client.
Spring supports development of REST resources in the following ways:
•	Controllers can handle requests for all HTTP methods, including the four primary REST methods: GET, PUT, DELETE, and POST.
•	The new @PathVariable annotation enables controllers to handle requests for parameterized URLs (URLs that have variable input as part of their path).
•	The <form:form> JSP tag from Spring’s form-binding JSP tag library, along with the new HiddenHttpMethodFilter, make it possible to submit PUT and DELETE requests from HTML forms, even in browsers that don’t support those HTTP methods.
•	Resources can be represented in a variety of ways using Spring’s view and view resolvers, including new view implementations for rendering model da-ta as XML, JSON, Atom, and RSS.
•	The representation best suited for the client can be chosen using the new
•	ContentNegotiatingViewResolver.
•	View-based rendering can be bypassed altogether using the new @ResponseBody annotation and various HttpMethodConverter implemen-tations.
•	Similarly, the new @RequestBody annotation, along with HttpMethodCon-verter implementations, can convert inbound HTTP data into Java objects passed into a controller’s handler methods.
•	RestTemplate simplifies client-side consumption of REST resources.
Spring Web Flow

Spring Web Flow is an extension to Spring MVC that enables develop-ment of flow based web applications. It does this by separating the definition of an application’s flow from the classes and views that implement the flow’s behavior.
All requests to a flow first go through Spring MVC’s DispatcherServlet. From there, a handful of special beans in the Spring application context must be configured to handle the flow request and execute the flow.
Several of the web flow beans are declared using elements from Spring Web Flow’s Spring configuration XML namespace. Therefore, we’ll need to add the namespace declaration to the context definition XML file. 
In Spring Web Flow, a flow is defined by three primary elements: states, transitions, and flow data.
States are points in a flow where something happens. If you imagine a flow as being like a road trip, then states are the towns, truck stops, and scenic stops along the way.
Instead of picking up a bag of Doritos and a Diet Coke, a state in a flow is where some logic is performed, some decision is made, or some page is pre-sented to the user.
If flow states are like the points on a map where you might stop during a road trip, then transitions are the roads that connect those points. In a flow, you get from one state to another by way of a transition.

CONCLUSION

Spring aims to make enterprise Java development easier and to promote loosely coupled code. Vital to this is dependency injection and AOP. Wegot a taste of dependency injection in Spring. DI is a way of associating application objects such that the objects don’t need to know where their dependencies come from or how they’re implemented. Rather than acquiring dependencies on their own, dependent objects are given the objects that they depend on. Be-cause dependent objects often only know about their injected objects through interfaces, coupling is kept low. In addition to dependency injection, we also saw a glimpse of Spring’s AOP sup-port. AOP enables you to centralize logic that would normally be scattered throughout an application in one place an aspect. When Spring wires your beans together, these aspects can be woven in at runtime, effectively giving the beans new behavior. Dependency injection and AOP are central to everything in Spring. Thus you must understand how to use these principal functions of Spring to be able to use the rest of the framework. 

BIBLIOGRAPHY
1. Craig Walls, Spring in Action / Craig Walls. – New York, 2011. – 424 p.
2. Bruce Eckel, Thinking In Java / Bruce Eckel. – New York, 2006. – 1057 p.
3. Steve McConnell, Code Complete / Steve McConnell. – New York, 2004. – 960 p.
4. Mak Gary, Spring Recipes: A Problem-Solution Approach / Mak Gary. – New York, 2007. – 1104 p.
5. Johnson Rod, Expert One-on-one J2EE Design and Development / Johnson Rod. – New York, 2002. – 750p.

